---
layout: post
title: PGSQL(7)-index-bloat
author: itsxun
date: 2018-10-08 14:23:14 +0800
catalog: true
tags:
    - 数据库
---

## 引入

虽然pgsql默认的B树索引在insert方面性能不错，但是在delete的时候，会导致索引中存在的无效数据，导致索引膨胀。无效数据会占用着更多的内存，磁盘，导致更多的磁盘IO。

## Cause

可能导致索引膨胀的原因有三种：

1. 删除列：列的删除会让索引失效，索引页里面的索引如果全部失效了会回收利用，如果失效的索引越来越多，则索引页里面的无效数据会越来越多，造成索引膨胀。

2. PostgreSQL 9.0之前，Vacuum Full在搬动列的过程中，新位置的索引会先被建立，之后旧的索引才会被删除，所以会造成索引膨胀。

3. 长会话。长会话会阻塞vacuum，导致表中无效数据会越来越多，造成索引膨胀。

## 解决办法

1. Dump and restore
最简单粗暴的解决办法，pg_dump工具可以导出整个库，然后重建schema，导入数据。
这个办法几乎能解决所有的DB阻塞问题，但是缺点也很明显，代价相当昂贵。

2. Vacuum
vacuum会再次调整表，确保表的每页尽可能放满列。但是表占用磁盘大小可能不会发生明显收缩，因为仅仅满足表的尾部是连续的无效空间才会被回收。

3. Cluster
Cluster命令会根据指定的index来重新把表整理排序，就好像是表中的列就都是按照索引的顺序插入一样。一旦整理完成，旧的表会被删除。这个命令会在表上加写锁，并且要求临时性的两倍当前表的大小的磁盘空间剩余。执行完毕后，推荐使用ANALYZE更新表信息，以便于执行器更准确的选择执行计划。
Cluster在范围查找方面更有加速效果，一般来说，也能加速从多个数据来源下零碎数据查询。


4. Reindex
用来解决，当索引数据在磁盘上比较分散，或者无效数据太多，膨胀的厉害的情况。
