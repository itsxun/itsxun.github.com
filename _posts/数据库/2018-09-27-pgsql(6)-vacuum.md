---
layout: post
title: PGSQL(6)-vacuum
author: itsxun
date: 2018-09-27 16:55:24 +0800
catalog: true
tags:
    - 数据库
---

## vacuum是做什么的

由于PGSQL的MVCC，更新的列和删除的列并不会直接物理删除。事实上，当所有连接的客户端都不占用这些旧的列时，这些列就应该被删除。其次，新的列，如果最终未commit，或者之后rollback了，这些列也是应该被清理掉的。
所以，清理这些操作（update，insert，rollback）留下的没用的列就是vacuum所做的事。其次，vacuum还负责txid wrap。

## 普通vacuum清理过程

vacuum会扫描每一行，发现是不可见的废弃列就会加入到一个free space map。
有新列需要插入时，会去这个map里面寻找可用空间而不是直接去分配新空间。这个map有参数控制它占用内存上限的，如果内存不够用了，就不能放入新的可重复利用的空间，会对表产生灾难性的影响和引起索引膨胀。

## 给磁盘减负

普通的vacuum一般来说执行完后不会给省出多少空间。

有一种情况例外，vacuum能产生明显的效果：
  表的尾部有连续的大量的可删除的列。
产生这个现象的原因可能有，不断的往表里面插入数据，然后定期删除数据。整体上表的空间会趋于稳定。

大部分的情况下，vacuum并不会释放出磁盘空间。但是对待vacuum的态度应该是：经常性的，定时性的运行，保证表不会出现大量的连续的废弃的空间需要释放。

## Full Vacuum

终极杀招。会将有效列往表的前面移动，然后删除无效列。所以它能真正的解决MVCC带来的副作用。

然后，它也有副作用：
1. 它需要锁住整张表，并且，一般来说，会需要锁住较长的时间。
2. 它会对服务器的造成比较大的负载。9.5版本后提供了可多线程并行处理的参数，缩短了时间同时，更加加重了服务器的负载。
3. vacuum可能会导致索引膨胀

一处细节：
  9.6版本后，如果vacuum执行中，碰到那些长时间占用这某些无效列的会话，有一个叫做old_snapshot_threshold的参数，定义最长持有时间，超过这个时间后，vacuum会直接清除掉列，会话如果继续访问的话，会收到异常。

## 有节制的vacuum

因为vacuum可能会给服务器造成巨大的负载，所以，pgsql又提供了新的思路来让vacuum尽可能少耗资源的进行。
先来看几个参数：
Page hit: 需要的数据在缓存中找到了，不需要额外的磁盘操作。这个参数名：vacuum_cost_page_hit，默认为1，这个参数不应该被调整。

Page miss：需要的数据未在缓存中找到，需要去读磁盘。参数为 vacuum_cost_page_miss，默认为10。

Page dirty:数据修改后，需要写会磁盘，参数为：vacuum_cost_page_dirty,默认为20.

这三个参数，强烈建议不足修改保持默认值。

参数：vacuum_cost_limit是消耗上限，当vacuum在执行中，计算到消耗（默认为200）达到这个值的时候，会sleep vacuum_cost_delay 这么多毫秒。

在大型系统中，一般vacuum_cost_delay会设置在1~5ms，小型系统一般会设置成20ms.


## 对待vacuum的态度

vacuum是不可逃避的，同时当表太长时间没清理，执行时也是可能长时间会锁表，并且可能造成索引膨胀，对服务器造成更大的负载。但是正确的做法不是因为这些负面效果而抵制，而是应该经常性的，规律性的足够多的运行，保证表不会出现需要长时间vacuum的情况。

## 关于autovacuum

1. autowacuum是无法真正意义上关闭的。当txid将要到达临界值时，autovacuum会自动触发，即使关闭了autovacuum。没有任何理由关闭autovacuum。

2. autovacuum运行需要消耗内存，会从配置maintenance_work_mem中获取内存，如果不够了，会极大的影响vacuum的速度，导致表长时间锁着。
