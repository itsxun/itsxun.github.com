---
layout: post
title: redis分布式锁二：对于分布式锁的思考
author: itsxun
date: 2018-08-29 22:26:46 +0800
catalog: true
tags:
    - nosql
---

## 引入

在分布式的redis集群中，试想这么一种场景：

> 客户端1在master节点上获取到了分布式锁，随后master由于网络异常等等原因突然挂掉了，slave节点被提升为master节点，但是锁还未同步到slave节点上，随后客户端2在新的master节点上申请到了分布式锁，这个时候客户端1和客户端2都认为自己拿到了锁

这个实例只是想说明：在分布式系统的集群中，每个单机系统都可能会是不可靠的，因此，单机环境下能使用的分布式锁，在集群环境可能并不适用。

另外还有一个值得一提的问题：锁的生命周期的问题。

> 客户端1某个时间获取到了锁，然后开始访问共享资源。这里可能会有很多因素使得客户端1操作未完成，但是锁过期了。比如自身阻塞，网络超时。这个时候客户端2尝试获取锁，获取到了，这个时候两个客户端都认为自己获得了锁。

这个问题的矛盾主要在于锁的过期时间的设置。锁是肯定有必要过期的，但是时间设置会很尴尬，带着这个问题，继续往下看。


## redis官方锁：RedLock

关于redis分布式锁其实redis的作者已经提出了范例，称为RedLock.

> 实现过程

假设redis集群中一共有N个节点，一般N为单数。

1. 客户端获取当前的时间戳，精确到毫秒。

2. 客户端带着这个时间戳，和自身的ID，锁的过期时间，向集群中所有的redis节点请求锁，在一个请求失败后（可能由于网络不可达，可能由于锁已经被占用了），应该立即向下一个节点申请，并且，向某一个节点申请锁的消耗的时间应该远远小于锁的自身的过期时间（几十毫秒量级），

3. 计算整个过程花费了多少时间，用当前时间减去第一步的时间，如果计算得知，客户端在超过半数的redis节点上锁获取成功，并且未超时，则说明，锁获取成功。

4. 锁的生命周期重新计算，去掉前面操作消耗的时间。

5. 如果锁获取失败，应该立即向所有的redis节点发送释放锁的请求。之所以不仅仅向申请到了锁的节点发送释放锁的请求是因为，存在这样的场景：

> 在某一个节点上，锁申请成功了，但是在返回给节点成功信息的时候，网络阻塞了，导致节点以为没有获取到锁，这种情况下，释放锁请求也必须发送给该节点。

以上。

## 针对RedLock的思考分析

- 问题一：

在redis集群中，毫无疑问，锁只有获取到半数以上的申请才算拿到，这种方案可靠性更高。但是，开头就提到的锁数据可能丢失导致锁的安全性被打破的问题，还是存在。试想这种场景：

> 集群中有5个redis节点，分别是A,B,C,D,E。某个时刻，客户端1向集群中申请锁，获取到了A,B,C上的锁，但是D,E未获取到。某一个时刻，由于节点C突然挂掉，并且锁的数据未持久化到文件中，节点恢复重新上线后，锁的数据又丢失了（Redis在默认AOF的持久化策略下，极端条件可能会丢失2秒的数据）。这时候，客户端2申请锁，在C,D,E上获取到了锁，现在，客户端1和2都认为自己获取到了锁。

- 问题二：

锁过期导致的锁的安全性为题，这个并未解决。

另外，还有一个值得一提的问题：
  redlock中，大量的时间处理，对集群的整体时间要求非常高，可能会有，某一个节点时钟不准，导致的锁过早过期，从而再次产生锁的安全问题。

## 总结

RedLock并不是一个理想的分布式锁的实现方案。
如果只是轻量级的使用，单台redis实现的分布式锁方案是可行的。
但是在集群上，更应该考虑zookeeper之类的方案。

## 后话

看到这里是不是觉得很坑爹。。。

分布式系统的复杂性，不是任何一个人就能窥见一斑的。

学海无涯，共勉。

参考至：
[基于Redis的分布式锁到底安全吗](http://zhangtielei.com/posts/blog-redlock-reasoning.html)
